"""
UTILITY FUNCTIONS
"""
from typing import List

import numpy as np
import pandas as pd


#region Define the query, feedback, marker
class Marker:
    """
    Implement a marker (= a cycle)
    """

    def __init__(self, mid, mstart, mend, no_cyc, label, ext, data, input_len):
        """

        Parameters
        ----------
        mid
        mstart
        mend
        no_cyc
        label
        ext
        input_len
        """
        self.mid = mid
        self.mstart = mstart
        self.mend = mend
        self.no_cyc = no_cyc
        self.label = label
        self.ext = ext
        self.data = data
        self.input_len = input_len


class SelectedMarker:
    """
    A simple class to store the cycles selected by the humans (to be used specifically by the GUI)
    """

    def __init__(self, mid, mlabel):
        """

        Parameters
        ----------
        mid
            The ID of the marker
        mlabel
            The label in text
        """
        self.mid = mid
        self.mlabel = mlabel

    def __hash__(self):
        return hash((self.mid, self.mlabel))

    def __eq__(self, other):
        return self.mid == other.mid and self.mlabel == other.mlabel

    def __str__(self):
        return f'SelectedMarker: mid = {self.mid}, mlabel = {self.mlabel}'


class CandidateByExtractor:
    """
    Implement the candidate cycles of each extractor
    """

    def __init__(self, flattened: np.ndarray, markers: List[Marker]):
        """

        Parameters
        ----------
        flattened
        markers
        """
        self.flattened = flattened
        self.markers = markers

    def __str__(self):
        """

        Returns
        -------

        """
        content = '|'.join([f'ID={mk.mid}, START={mk.mstart}, END={mk.mend}, LABEL={mk.label}' for mk in self.markers])
        return f'({content})'


class Query:
    """
    Implement a query
    """
    candidates: dict[str, CandidateByExtractor]

    def __init__(self, X_id, X, candidates):
        """
        Create a new query

        Parameters
        ----------
        X_id
        X
        candidates
        """
        # the input this query is associated to (as a filename, for exanple)
        self.query_id = X_id

        # the data in full, already preprocessed
        self.data = X

        # the candidates generated by the extractor to this input, stored in the form of a dictionary
        self.candidates = candidates


class FeedbackItem:
    """
    One feedback cycle, containing the cycle data and the labels, used to update the knowledge K
    """

    def __init__(self, mlabel, mdata, fid):
        """

        Parameters
        ----------
        mlabel
        mdata
        fid
        """
        self.mlabel = mlabel
        self.mdata = mdata
        self.fid = fid
#endregion


def get_cycles(arr: np.ndarray) -> List[List[int]]:
    """
    Get indices of cycle (one cycle = a list of indices)
    """
    result = []
    cycle = []
    no_cycle = -1
    for i in range(len(arr)):
        if arr[i] != no_cycle:  # change to a new cycle
            if len(cycle) != 0:
                result.append(cycle.copy())
            cycle = []
            no_cycle = arr[i]
            if no_cycle != 0:  # if the new cycle number is not 0
                cycle.append(i)
                if i == len(arr) - 1:
                    result.append(cycle)
        else:  # still in the same cycle
            if arr[i] != 0:
                cycle.append(i)
                if i == len(arr) - 1:
                    result.append(cycle)
    return result


def pad_sequences(data: List, dim, maxlen=None):
    """
    Pad all the sequences in the list

    Parameters
    ----------
    data
    dim
        Dimension of the data
    maxlen
        If None, estimate the maximum length myself

    Returns
    -------

    """
    # return empty if there are no item in the input
    if len(data) == 0:
        return []

    # if maxlen is not supplied, estimate it ourselves
    if maxlen is None:
        maxlen = max([len(d) for d in data])

    # pad the sequences (pre-concatenate)
    result = []
    for item in data:
        delta = maxlen - len(item)

        # if the item has the length equal to maxlen, just add it in the result and do nothing
        if delta == 0:
            result.append(item)
        # if the length of item is shorter than maxlen, pad it
        elif delta > 0:
            pad = np.zeros((delta, dim), dtype=float)
            item_ = np.concatenate((pad, item), axis=0)  # axis = 0 to add to the row
            result.append(item_)
        # if the length of item is longer than maxlen, cut it (from the beginning)
        else:
            start = len(item) - maxlen
            item_ = item[start:]
            result.append(item_)

    # return the result
    return result


#region Preprocessing the data
def preprocess(X, case: str):
    """
    Preprocess the data, depending on the data sets

    Parameters
    ----------
    X
        The data to preprocess
    case: str
        'nat' or 'r2n'

    Returns
    -------

    """
    if case.lower() == 'nat':
        return preprocess_nat(X)
    else:
        return preprocess_r2n(X)


def preprocess_nat(X: pd.DataFrame):
    """
    Set all attributes of the footstep to 0

    Parameters
    ----------
    X

    Returns
    -------

    """
    # if the data contain nothing, return None
    N = len(X)
    if N == 0:
        return None

    # if the data contain all null signals, return None as well
    n_non0 = np.count_nonzero(X[['pmot', 'umot', 'imot']].values)
    if n_non0 == 0:
        return None

    # map ID to the door or the footstep
    mapped_id = np.zeros(N)
    for i in range(N):
        row = X.iloc[i]
        ID = row['id']
        if ID == 32 or ID == 33:
            mapped_id[i] = 1  # door
        if 34 <= ID <= 37:
            mapped_id[i] = 2  # footstep
        if ID == 16:
            mapped_id[i] = mapped_id[i-1] if i > 0 else mapped_id[i+1]
    X['mapped_id'] = mapped_id

    # separate porte and marche data
    idx_p = np.where(X['mapped_id'] == 1)[0]

    # if the data contain no door signal, return None as well
    if len(idx_p) == 0:
        return None

    # door data
    pmot_p, umot_p, imot_p = np.zeros(N), np.zeros(N), np.zeros(N)
    pmot_p[idx_p] = X['pmot'][idx_p]
    umot_p[idx_p] = X['umot'][idx_p]
    imot_p[idx_p] = X['imot'][idx_p]
    X['pmot_p'] = pmot_p
    X['umot_p'] = umot_p
    X['imot_p'] = imot_p

    return X


def preprocess_r2n(X):
    """
    Preprocess R2N data file

    Parameters
    ----------
    X

    Returns
    -------

    """
    # work on a copy
    x = X.copy()

    # if the data contain nothing, return None
    N = len(x)
    if N == 0:
        return None

    # if the data contain all null signals, return None as well
    n_non0 = np.count_nonzero(
        X[['courant_moteur_de_la_porte', 'tension_moteur_de_la_porte', 'position_moteur_de_la_porte']].values
    )
    if n_non0 == 0:
        return None

    # convert the timestamp to miliseconds and change the column's name to 'time'
    x['time'] = x['timestamp'] / 1e3

    # return the preprocessed dataframe
    return x

#endregion
